<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tiling experiment</title>

    <style>


    </style>
</head>
<body>

   <script>
        const PRIMARY_COLOUR = '#8DA05E'
        const SECONDARY_COLOUR = '#E9EDE0'
        const PLAYER_COLOUR = '#2A2C41'
        const POINT_COLOUR = '#FDBF50'
        const gameSpaceCanvas = document.querySelector('#game-space')
        const gameSpaceCanvasContext = gameSpaceCanvas.getContext('2d')
        const { height, width } = gameSpaceCanvas
        const pixelSize = parseInt(gameSpaceCanvas.dataset.pixelSize)
        const numberOfColums = width / pixelSize
        const numberOfRows = height / pixelSize
        let isFirstLoad = true

        function renderTiles() {
            if(height % pixelSize !== 0 || width % pixelSize !== 0) throw new Error('Provide a valid pixel size')
            const getFillColour = (i, j) => {
                const condition = j % 2 === 0

                if(i % 2 === 0) return condition ? PRIMARY_COLOUR: SECONDARY_COLOUR 
                return condition ? SECONDARY_COLOUR : PRIMARY_COLOUR
            }

            for(let i = 0; i <= numberOfRows; i++) {
                // Draw colums
                for(let j = 0; j <= numberOfColums; j++) {
                    const x = j * pixelSize
                    const y = i * pixelSize
                    const fillColour = getFillColour(i, j)
                    
                    gameSpaceCanvasContext.fillStyle = fillColour
                    gameSpaceCanvasContext.fillRect(x, y, pixelSize, pixelSize)
                }
            }
        }

        class Player {
            fillColour = PLAYER_COLOUR

            constructor(pointManager) {
                this.pointManager = pointManager
            }
           
            init() {
                const middleValue = ((numberOfColums - 1) / 2 ) 
                this.x = middleValue * pixelSize
                this.y = middleValue * pixelSize
            }
            
            render() {
                gameSpaceCanvasContext.fillStyle = this.fillColour
                gameSpaceCanvasContext.fillRect(this.x, this.y, pixelSize, pixelSize)
                this.pointManager.tryToScore(this.x, this.y)
            }

        }

        class PlayerController {
            constructor(player) {
                this.player = player
                this.register()
            }

            register() {
                document.addEventListener('keydown', this.listener.bind(this))
            }

            listener({ key }) {
                switch (key) {
                    case 'w':
                        this.up()
                        break
                    case 'd':
                        this.right()
                        break
                    case 's':
                        this.down()
                        break
                    case 'a': 
                        this.left()
                        break
                }
            }

            up() {
                if (this.player.y > 0) {
                    this.player.y -= pixelSize
                }
            }

            down() {
                if(this.player.y < height - pixelSize) {
                    this.player.y += pixelSize
                }
            }

            left() {
                if (this.player.x > 0) {
                    this.player.x -= pixelSize
                }
            }

            right() {
                if(this.player.x < width - pixelSize) {
                    this.player.x += pixelSize
                }
            }
        }

        class Point {
            fillColour = POINT_COLOUR

            constructor(x, y) {
                this.x = x
                this.y = y
            }

            render() {
                gameSpaceCanvasContext.fillStyle = this.fillColour
                gameSpaceCanvasContext.fillRect(this.x, this.y, pixelSize, pixelSize)
            }
        }

        const randomMultipleInRange = (multipleOf, max) => Math.floor(Math.random() * max) * multipleOf

        class GameManager {
            pointsPerScore = 20
            points = 0
            pointsMissed = 0

            init() {
                this.points = 0
                this.pointsMissed = 0
                this.updatePoints()
            }

            scorePoint() {
                this.points += this.pointsPerScore
                this.updatePoints()
            }

            updatePoints() {
                const $numberOfPoints = document.querySelector('.number-of-points')
                $numberOfPoints.innerHTML = this.points
                const $pointsMissed = document.querySelector('.missed-points')
                $pointsMissed.innerHTML = this.pointsMissed
            }

            missedPoint() {
                this.pointsMissed -= this.pointsPerScore
                this.updatePoints()
            }
        }

        class PointManager {
            timeToLive = 3000;
            points = {};
           
            constructor(gameManager) {
                this.gameManager = gameManager
            }
            
            createRandomPoint() {
                const randomColumInRange = randomMultipleInRange(pixelSize, numberOfColums)
                const randomRowInRange = randomMultipleInRange(pixelSize, numberOfColums)

                const point = new Point(randomColumInRange, randomRowInRange)
                this.points[this.getPointKey(point.x, point.y)] = point

                setTimeout(() => {
                    this.removePoint(point)
                    this.gameManager.missedPoint()
                }, this.timeToLive)
            }

            init() {
                this.points = {}
            }

            render() {
                Object.values(this.points).forEach(point => point.render())                
            }

            getPointKey(x, y) {
                return `(${x}-${y})`
            }

            getPoint(x, y) {
                return this.points[this.getPointKey(x, y)]
            }

            removePoint(point) {
                delete this.points[this.getPointKey(point.x, point.y)]
            }

            tryToScore(x, y) {
                const point = this.getPoint(x, y)
                if(!point) return
                
                this.removePoint(point)
                this.gameManager.scorePoint() 
            }
        }

        const gameManager = new GameManager()
        const pointManager = new PointManager(gameManager)
        const player = new Player(pointManager)
        new PlayerController(player)

        // Bind reset button
        document.querySelector('.restart-button')
            .addEventListener('click', () => (isFirstLoad = true))

        let frames = 0
        const FRAMES_UNTIL_POINT = 15
        function main() {
            frames++
            gameSpaceCanvasContext.beginPath()
            if(isFirstLoad) {
                pointManager.init()
                player.init()
                gameManager.init()
                isFirstLoad = false
            }

            renderTiles()

            if(frames % FRAMES_UNTIL_POINT === 0) {
                pointManager.createRandomPoint()
            }

            pointManager.render()
            player.render()
            gameSpaceCanvasContext.closePath()
            
        }
        setInterval(main, 60)
   </script>
</body>
</html>

